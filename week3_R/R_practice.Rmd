---
title: "Practice in R"
author: Nicole Black
date: 07/16/22
---

Answer the following questions to the best of your ability. DO NOT use loops in your implementation (it isn't necessary for any of these questions). If you have questions, be sure to reach out to Nicole/TAs via slack, or attend office hours! We're always are happy to help!

Finally, if you get stuck, here are some common mistakes to check for:

  1. Forgetting to put quotes around a string (or vise versa)
  2. Missing an open or close parenthesis
  3. Calling a function on an argument of the wrong data type
  4. Overwriting your data and wondering why downstream code doesn't work (this is why we recommend you make a copy of your original data frame and only edit that copy)
  5. General types, spelling errors, misplaced punctuation, etc.
  
Download the data sets we will be using in this homework: 

```{r}
data(attenu) # peak earthquake accelerations measured at various observation sites
data(iris) # various measurements for flowers of different species
```

###### Boolean Masking

Use is.na() to identify any rows with missing station data in the attenu data set. Save the output of your is.na() statement to a vector called "na_boolean_mask", then print it to view it.

```{r}
# write code here
```

Use the sum() function on na_boolean_mask. What does this number represent? Remember this value for later (you can save it in a variable if you would like).

```{r}
# write code here
```

Remember that boolean values are TRUEs and FALSEs. A boolean mask is a vector of boolean values that can be applied to a data frame within the [row, column] notation. If you apply the mask in the row section [mask , ] then R will go through all of the rows of your data frame and check if the corresponding value in the boolean mask vector is a TRUE or a FALSE. TRUE rows are select, and FALSE rows are ignored. The syntax is as follows:

```{r}
mask <- c(TRUE, TRUE, FALSE, FALSE, TRUE)

df_cleaned <- df[mask, ] # with above mask placed in the rows section here, the cleaned data frame will contain all of the data for rows 1, 2, and 5
```

Copy the above syntax to create a new data frame called "attenu_cleaned".

THINK: When using is.na(), are NA values assigned TRUE or FALSE. With this information in mind, what does TRUE mean in your boolean mask? Is that data we want to keep, or data we want to ignore. 

```{r}
# write code here
```

View your attenu_cleaned data frame to confirm you have cleaned it as intended.

```{r}
# write code here
```

Use the function nrow() to count the number of rows in attenu and attenu_cleaned. Given the number of TRUEs and FALSEs in na_boolean_mask, do these values make sense? What is the relationship between these numbers?

```{r}
# write code here
```

###### Writing functions

A common plot might be comparing the data in two columns and color coding them based on a third level of data.

Write a function called plot_func(x, y) that takes in two arguments, the x-axis data and the y-axis data.

Your function should do the following:

  1. Identify the mean of the x-axis data and the y-axis data.
  2. Use a series of nested ifelse() statements to create the colors vector. In a nested ifelse(), the "else" condition is to run another ifelse(), and so on. Make sure to close the nest with the correct number of parentheses! This vector should hold four colors. Assign a color to each of the following scenarios:
    a. x is greater than its mean and y is greater than its mean
    b. x is greater than its mean but y is less than its mean
    c. x is less than its mean and y is less than its mean
    d. x is less than its mean but y is greater than its mean
  3. Convert the colors vector into a factor.
  4. Print the correlation between x and y by using print(cor.test(x, y))
  4. Use plot() to plot x and y, colored using the color vector (now a factor). Use abline() to plot a vertical line at the x-axis mean a horizontal line at the y-axis mean. For more info on plotting with plot() and abline(), use "?plot" and "?abline".
  
Note: If you write multiple plotting lines, they will all show up on top of each other on the same plot. This can be useful at times (like in the situation above, where we want plot() and abline() to be on the same graph). If you want to create a separate plot, use "dev.off()" to clear the window and start fresh.

```{r}
# write function here

# run these lines (one by one) to test your function
plot_func(attenu_cleaned$mag, attenu_cleaned$accel)

plot_func(iris$Sepal.Length, iris$Sepal.Width)
```

###### Plotting

In the above exercise, you learned how to make a scatterplot. There are many types of plots in R, each with many types of customizations. Here we will create a boxplot, histogram, and Draftsman's or Pairs Scatter Plots. The associated functions are boxplot(), hist(), and pairs().

Create a boxplot that splits the sepal length data into groups by species.

```{r}
# write code here
```

Create a histogram of petal length.

```{r}
# write code here
```

Create a Draftsman's or Pairs Scatter Plot that looks at the sepal length, sepal width, petal length, and petal width colored by the species. You can play around with various other arguments to make this plot as readable as possible. (HINT: Google how to color by factor with the "col" argument)

```{r}
# write code here
```

The Draftsman's plot above is interesting since it looks like using these four measurements, a fairly accurate species prediction can be made! This is an example of a cluster analysis, and you can certainly use a plot like this one later on to explore cancer predictors.

###### Writing files/saving plots

Often, we want to save results data frames to a local machine so they can be saved, shared, or further explored with other software. To do this, we have to "write" the file. To do this, use write.csv() as follows:

```{r}
write.csv(dataframe, "/PATH/TO/DESTINATION/dataframe.csv") # in R, file paths are strings so don't forget the quotes!
```

Save the attenu_cleaned to your desktop, then view it from your GUI.

```{r}
# write code here
```

Along with writing files, we oftentimes want to read files into our R environment. These files could be result files, raw data, etc. We read in csv files using read.table() as follows:

```{r}
read.table("/PATH/TO/FILE/file.csv", header = TRUE, sep = "\t")
```

The header (boolean value) tells R whether the file contains the names of the variables as the first line. The sep argument tells R what is used as a separater character. You might have heard of csv (comma separated value) files or tsv (tab separated value) files. This defaults to "," for a csv, but if your file is tab separated, you can specify that with "\t".

Read in your attenu_cleaned file.

```{r}
# write code here
```

We also oftentimes want to save our plots. You can do this as follows:

```{r}
jpeg("/PATH/TO/DESTINATION/plot.jpg") # choose any file extension, typically jpg and pdf are most common
plot(x,y) # put all of your plotting lines here
dev.off() # close the plotting environment and save the plot
```

Adapt your histogram plot to be saved to your desktop.

```{r}
# write code here
```

###### Looking Ahead

In our next class, we will be using the TCGAbiolinks package. Go ahead and install (and just for practice, load) that now:

```{r}
# install package

# load package

```
